#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass tufte-book
\begin_preamble
\usepackage{pgfplots}
\usetikzlibrary{patterns}
\usepackage{filecontents}
\setcounter{tocdepth}{2}
\setcounter{secnumdepth}{2}

\begin{filecontents*}{data/windows_success_rate.csv}
\end{filecontents*}
\pgfmathdeclarefunction{gauss}{2}{%
  \pgfmathparse{1/(#2*sqrt(2*pi))*exp(-((x-#1)^2)/(2*#2^2))}%
}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style french
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
title[Identificazione audio resistente al rumote in WebAssembly]{
\end_layout

\begin_layout Plain Layout

  
\backslash
mbox{Identificazione} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\backslash
mbox{audio resistente} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\backslash
mbox{al rumore} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\backslash
mbox{in WebAssembly}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Author
Davide Pisanò - Antonio Servetti
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduzione
\end_layout

\begin_layout Standard
Negli ultimi anni si è notato un trend sempre crescente nell'utilizzo di
 JavaScript per la creazione di applicazioni desktop.
\end_layout

\begin_layout Standard
Ci sono diversi fattori che hanno contribuito alla popolarità di JavaScript,
 primo fra tutti è che rappresenta il linguaggio standard, de facto, per
 l'implementazione di funzionalità dinamiche su pagine web.
 Nello specifico, JavaScript è l'unico linguaggio di scripting supportato
 nativamente da tutti i browser web moderni.
\end_layout

\begin_layout Standard
Ci sono stati dei tentativi per introdurre alcune novità in questo ambito,
 seguendo principalmente due approcci:
\end_layout

\begin_layout Enumerate
l'inclusione di una nuova macchina virtuale all'interno di un browser web
 che supportasse un nuovo linguaggio
\end_layout

\begin_layout Enumerate
la realizzazione di un nuovo linguaggio ma eseguito sulla stessa macchina
 virtuale JavaScript già presente in un web browser
\end_layout

\begin_layout Standard
Ricade nella prima categoria VBScript di Microsoft, basato su Visual Basic,
 introdotto a metà degli anni '90, oggi non più supportato da nessun browser
 moderno.
\end_layout

\begin_layout Standard
Nella seconda categoria possiamo annoverare, più recentemente, TypeScript
 (sempre di Microsoft), CoffeeScript e Dart (di Google).
 Questi linguaggi sono basati su un cosiddetto 
\emph on
transpiler
\emph default
, ovvero un compilatore che prende in input il codice sorgente scritto ad
 esempio in TypeScript e lo converte in codice JavaScript, mantenendo le
 stesse funzionalità del codice originale.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

Un altro punto di forza di JavaScript è la sua facilità di apprendimento,
 soprattutto rispetto ad altri linguaggi di programmazione più a basso livello
 come C o C++, permettendo agli sviluppatori di iniziare a scrivere codice
 più rapidamente, senza dover investire troppo tempo nell'apprendimento
 di una nuova tecnologia.
 Oggi, infatti, si assiste ad una quantità sempre crescente di librerie
 e framework per JavaScript, atti a semplificare lo sviluppo di applicazioni
 web complesse e a migliorarne la qualità, giusto per citarne alcuni: React,
 Angular, Vue.js, ma anche il più 
\begin_inset Quotes eld
\end_inset

anziano
\begin_inset Quotes erd
\end_inset

 jQuery.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Per questi ed altri motivi, durante la fine degli anni 2000, ci si è iniziati
 a porre una domanda: 
\begin_inset Quotes eld
\end_inset

è possibile eseguire codice JavaScript al di fuori del contesto web browser?
\begin_inset Quotes erd
\end_inset

.
 La risposta (affermativa) a questa domanda è stata la nascita di Node.js
 che ha dato il via al paradigma del 
\emph on
JavaScript everywhere
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
Del quale non mancano i detrattori
\end_layout

\end_inset

.
 Questo vuol dire, in estrema sintesi, poter utilizzare lo stesso linguaggio
 per creare applicazioni web, sia lato front-end sia lato back-end.
 In teoria si potrebbe così ridurre il tempo necessario per il processo
 di sviluppo di un'applicazione, riducendo il portfolio di tecnologie che
 un programmatore deve conoscere.
\end_layout

\begin_layout Standard
Nei primi anni 2010, quando Node.js iniziava a prendere piede, ci si è posti
 un'altra domanda 
\begin_inset Quotes eld
\end_inset

è possibile scrivere e distribuire applicazioni desktop/mobile scritte in
 JavaScript?
\begin_inset Quotes erd
\end_inset

.
 La risposta, ancora una volta, è stata affermativa.
 Nasce Electron: un framework open-source che consente agli sviluppatori
 di creare applicazioni desktop multi-piattaforma utilizzando tecnologie
 web standard come HTML, CSS e JavaScript.
 Dal lato mobile nascono tecnologie analoghe a Electron come Ionic, React
 Native e PhoneGap, tutte con obiettivi abbastanza simili.
 Man mano l'ecosistema JavaScript ha iniziato a diventare quello che Java
 era nei primi anni 2000 per la scrittura di applicazioni desktop consumer
 multipiattaforma.
\end_layout

\begin_layout Standard
Il motivo principale dietro alla popolarità di questo ecosistema basato
 su JavaScript è la possibilità di utilizzare un'unica codebase (in JavaScript)
 che può essere eseguita su piattaforme molto diverse tra loro, problematica
 che è molto sentita nell'ambito mobile dove si hanno due piattaforme completame
nte diverse: Android e iOS
\begin_inset Foot
status open

\begin_layout Plain Layout
All'epoca della prima apparizione di queste tecnologie bisognava supportare
 anche Windows Phone
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Il trend di scrivere applicazioni in JavaScript è stato amplificato dalla
 crescente importanza del web come piattaforma per la distribuzione di applicazi
oni software.
 Software utilizzati quotidianamente da miliardi di utenti sono basati sul
 web e, per forza di cose, devono essere scritti in JavaScript.
\end_layout

\begin_layout Standard
Da qui la nascita delle cosiddette 
\emph on
Rich Internet Applications
\emph default
 (RIA), ovvero applicazioni web che offrono un'esperienza utente interattiva
 e avanzata simile a quella di un'applicazione desktop tradizionale.
 Le RIA sono caratterizzate da una vasta gamma di funzionalità e interattività
 che le distinguono dalla semplici pagine web statiche.
 Oltre alla classica triade HTML + CSS + JavaScript le RIA possono fare
 uso di tecnologie più avanzate e recenti come WebSockets, WebAudio, WebAssembly
, WebRTC, WebVR, WebGPU, Web Animations API.
 In sostanza il browser diventa un'interfaccia o un'astrazione della macchina
 sottostante, alla quale si può accedere utilizzando JavaScript.
\end_layout

\begin_layout Standard
Nello specifico WebAudio è un'API JavaScript avanzata che consente di manipolare
 e generare audio all'interno del browser.
 È stata progettata per consentire agli sviluppatori di creare RIA che includono
 funzionalità audio, come la registrazione, la riproduzione e l'elaborazione
 di suoni.
 L'API è basata su un'architettura a nodi, dove ogni nodo rappresenta una
 singola operazione di elaborazione del suono.
 I nodi possono essere collegati tra loro per creare una catena di elaborazione,
 in cui il suono viene elaborato in successione da ogni nodo che attraversa.
 La manipolazione del suono avviene in real time.
 WebAudio è oggi supportato su tutti i browser recenti basati sugli engine
 JavaScript V8 e SpiderMonkey.
\end_layout

\begin_layout Standard
La necessità di scrivere applicazioni real time ha portato la necessità
 di dover eseguire codice ad alta efficienza, obiettivo non realizzabile
 completamente con un linguaggio interpretato quale JavaScript.
 Alla fine degli anni 2010 nasce quindi 
\emph on
WebAssembly
\emph default
 (Wasm): un formato di codice binario portabile che consente di eseguire
 codice di basso livello all'interno del browser web.
 È stato progettato per essere compatibile con i linguaggi di programmazione
 come C, C++ e Rust.
 In pratica, quindi, Wasm permette di creare applicazioni web che eseguono
 codice più velocemente e con maggiore efficienza rispetto a soluzioni basate
 su JavaScript.
 Wasm è stato pensato per essere altamente interoperabile con JavaScript:
 codice JavaScript può richiamare codice Wasm e viceversa, creando quindi
 soluzioni ibride che combinano il meglio di entrambi i mondi.
\end_layout

\begin_layout Standard
Sfruttando tutte queste tecnologie e un ecosistema ormai maturo, l'obiettivo
 di questa tesi è quello di discutere la realizzazione di un sistema per
 l'identificazione di audio: un utente sottopone uno spezzone di un brano
 audio di pochi secondi al sistema, il quale risponde col nome di quel brano.
 L'obiettivo principale è quello di eseguire l'algoritmo di identificazione
 su dispositivi eterogenei all'interno di un web browser, utilizzando Wasm
 e WebAudio.
 Questo presenta numerosi vantaggi, tra i più importanti si possono individuare:
\end_layout

\begin_layout Itemize
l'evitare all'utente il download di un'app addizionale, potendo sfruttare
 le funzionalità dell'algoritmo di riconoscimento direttamente dal suo web
 browser
\end_layout

\begin_layout Itemize
la notevole riduzione del carico lato server: grazie alla sua architettura
 distribuita, parte della complessità viene spostata sul dispositivo dell'utente
 finale, il quale porta a termine buona parte del processo di identificazione,
 rendendo possibile un'identificazione più veloce ed efficiente rispetto
 ad altre applicazioni simili
\end_layout

\begin_layout Standard
In definitiva, si renderà l'esperienza dell'utente ancora più piacevole
 e soddisfacente, mantenendo le stesse funzionalità e caratteristiche di
 una classica app eseguita nativamente su un dispositivo dell'utente.
\end_layout

\begin_layout Section
Architettura generale
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset External
	template Inkscape
	filename img/architettura_generale.svg
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Schema-architettura-generale"

\end_inset

Schema architettura generale
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'architettura di base del sistema (in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Schema-architettura-generale"
plural "false"
caps "false"
noprefix "false"

\end_inset

), seppur ispirata al modello client/server, si discosta dalla tradizionale
 asimmetria tra i due attori, in cui il primo agisce come mero terminale
 passivo
\begin_inset Foot
status open

\begin_layout Plain Layout
In gergo tecnico è ciò che si definisce 
\emph on
dumb terminal
\end_layout

\end_inset

, limitandosi a interagire con l'API del server.
 La nuova soluzione adottata, invece, si propone di spostare parte della
 logica di business dal server al client, in un'ottica distribuita che avvicina
 la computazione all'utente e alleggerisce, al contempo, il carico sul server
 centrale, riducendo così i costi correlati.
 Tale approccio innovativo sfrutta le risorse disponibili sui dispositivi
 dell'utente, aumentando la scalabilità del sistema e garantendo prestazioni
 elevate e una maggiore efficienza.
 Questa soluzione rappresenta un notevole passo avanti nella progettazione
 di applicazioni web avanzate, fornendo un'esperienza utente fluida e gradevole.
\end_layout

\begin_layout Subsection
Scomposizione dell'architettura
\end_layout

\begin_layout Standard
\noindent
L'architettura (in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Schema-architettura-generale"
plural "false"
caps "false"
noprefix "false"

\end_inset

) può essere scomposta come segue:
\end_layout

\begin_layout Enumerate
Si inizia dai brani originali, la canzone nella sua interezza, salvata su
 una memoria di massa.
 La canzone è sottoposta ad una algoritmo di 
\emph on
fingerprinting
\emph default
, in cui vengono estratte alcune features
\begin_inset Foot
status open

\begin_layout Plain Layout
In seguito queste features prenderanno il nome di 
\emph on
Links
\end_layout

\end_inset

 caratterizzanti.
\end_layout

\begin_layout Enumerate
Le features estratte vengono memorizzate all'interno di un database insieme
 al nome della canzone alla quale appartengono.
\end_layout

\begin_layout Enumerate
Si immagini quindi che, ad un certo punto, un client voglia avviare il processo
 di riconoscimento di un brano: viene registrato uno spezzone audio di pochi
 secondi e viene innescata la stessa procedura di 
\emph on
fingerprinting
\emph default
 al punto 1 sul client, ma in questo caso le features estratte vengono inviate
 ad un endpoint REST.
\end_layout

\begin_layout Enumerate
Il server REST cerca di individuare delle similarità tra le features già
 presenti nel database e quelle appena inviategli dal client.
\end_layout

\begin_layout Enumerate
Se la ricerca ha successo, il server REST estrae dal database il nome della
 corrispondenza migliore.
\end_layout

\begin_layout Enumerate
Se la ricerca ha successo, il server REST invia al client il nome della
 corrispondenza migliore.
\end_layout

\begin_layout Standard
Si noti, anzitutto, che la parte più intensiva dal punto di vista computazionale
 è l'estrazione delle features, al contrario la ricerca delle similarità,
 sebbene impegnativa, non lo è quanto l'estrazione delle features stesse
\begin_inset Foot
status open

\begin_layout Plain Layout
Ulteriori considerazioni sull'argomento verranno fatte in seguito
\end_layout

\end_inset

.
 In altre parole, il momento di maggior carico computazionale si verifica
 in due fasi:
\end_layout

\begin_layout Itemize

\emph on
Lato server
\emph default
: solo nella fase iniziale che porta al popolamento del database, durante
 l'analisi dei brani originali (ovvero fasi 1 e 2)
\end_layout

\begin_layout Itemize

\emph on
Lato client
\emph default
: nell'estrazione delle features della registrazione del brano da riconoscere
\end_layout

\begin_layout Standard
In altre parole, l'operazione più onerosa per il server viene eseguita una
 sola volta: all'atto del fingerprinting dei brani originali.
 Sarà poi il client a farsi carico dell'operazione di fingerprinting per
 l'identificazione del singolo brano.
\end_layout

\begin_layout Standard
Il server REST ha una duplice funzione:
\end_layout

\begin_layout Itemize
Presentare i dati nel formato corretto sia lato client che lato database,
 fungendo quindi da una sorta di relay e disaccoppiando la rappresentazione
 interna dei dati a quella esposta al client
\end_layout

\begin_layout Itemize
Individuare similarità con le features già presenti nel database
\end_layout

\begin_layout Standard
L'intero sistema verrà descritto in modo più dettagliato nei capitoli successivi.
\end_layout

\begin_layout Section
Organizzazione del codice
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset External
	template Inkscape
	filename img/organizzazione_codice.svg
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Organizzazione-codice"

\end_inset

Schema organizzazione codice
\end_layout

\end_inset


\end_layout

\end_inset

Il codice sorgente del sistema è suddiviso nei seguenti componenti (figura
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Organizzazione-codice"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\end_layout

\begin_layout Itemize
La libreria 
\emph on
fin
\emph default
, deputata all'estrazione delle features (ovvero fare 
\emph on
fingerprinting
\emph default
) dei brani in esame.
\end_layout

\begin_layout Itemize
La libreria 
\emph on
fin_db
\emph default
 preposta all'interazione con il database, svolgendo i compiti di inserimento
 e ricerca delle features.
 Dipende da 
\emph on
fin
\emph default
.
\end_layout

\begin_layout Itemize
L'eseguibile 
\emph on
mock_client
\emph default
, riservato esclusivamente ad attività di testing, il quale riceve in input
 un segmento noto di un brano, al fine di verificare la corretta identificazione
 del brano stesso.
 Dipende da entrambe le librerie.
\end_layout

\begin_layout Itemize
L'eseguibile 
\emph on
server_entry
\emph default
,
\emph on
 
\emph default
in grado di elaborare i brani completi per estrarne le features, per poi
 memorizzarle nel database insieme al nome del brano associato
\end_layout

\begin_layout Itemize
L'eseguibile
\emph on
 server_rest
\emph default
 che espone l'endpoint REST per l'individuazione dei brani: riceve le features
 del segmento audio estratte dal client, effettua una ricerca di un brano
 compatibile all'interno del database e, in caso di esito positivo, restituisce
 al client il nome del brano individuato.
 Dipende da entrambe le librerie.
\end_layout

\begin_layout Itemize
L'eseguibile
\begin_inset Foot
status open

\begin_layout Plain Layout
In realtà l'eseguibile è la RIA, contenente HTML, il modulo Wasm e il codice
 JavaScript necessario al caricamento del modulo Wasm
\end_layout

\end_inset

 
\emph on
wasm
\emph default
, ovvero il client, in grado di acquisire il segmento audio tramite microfono
 del client, estraendone le features per poi inviarle a 
\emph on
server_rest
\emph default
.
\end_layout

\begin_layout Standard
Successivamente, nei prossimi capitoli, verranno esaminate in dettaglio
 le specifiche funzionalità di ciascun componente sopracitato.
\end_layout

\begin_layout Chapter
La libreria fin
\end_layout

\begin_layout Standard
La libreria 
\emph on
fin
\emph default
 è il componente principale del sistema e ha il compito di estrarre le features
 caratterizzanti di un brano, garantendo il più possibile, che audio simili
 abbiano features simili.
 D'ora in avanti ci si riferirà alle features indicandole come 
\emph on
Links
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset External
	template Inkscape
	filename img/fin_architettura.svg
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Architettura-fin"

\end_inset

Schema architettura libreria fin
\end_layout

\end_inset


\end_layout

\end_inset

Il punto di ingresso della libreria è un 
\emph on
Reader
\emph default
, ovvero un contenitore dei campioni che compongono un audio; in uscita
 si hanno i 
\emph on
Links
\emph default
 che caratterizzano quell'audio.
 Analizzando più dettagliatamente lo schema in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Architettura-fin"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\end_layout

\begin_layout Enumerate

\series bold
Reader
\series default
 è una classe astratta del namespace 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

readers
\end_layout

\end_inset

, la rappresentazione di un audio nel dominio del tempo.
 La classe definisce un metodo virtuale puro 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

getData()
\end_layout

\end_inset

 che restituisce i campioni dell'audio.
\end_layout

\begin_layout Enumerate

\series bold
Spectrogram
\series default
 è una classe del namespace 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

math
\end_layout

\end_inset

, rappresenta lo spettrogramma di un audio.
 Riceve i campioni dal 
\emph on
Reader
\emph default
 e procede come segue:
\end_layout

\begin_deeper
\begin_layout Enumerate
Finestra il segnale ottenendone un segmento
\end_layout

\begin_layout Enumerate
Calcola la DFT per ogni segmento
\end_layout

\begin_layout Enumerate
Calcola il modulo dell'output della DFT per ogni segmento
\end_layout

\begin_layout Enumerate
Salva il risultato del punto precedente in una struttura chiamata 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

fftWindow
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Le varie 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

fftWindow
\end_layout

\end_inset

 compongono lo spettrogramma, in altre parole una rappresentazione in frequenza
 dell'audio
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
findPeaks
\series default
 è una funziona nel namespace 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

core
\end_layout

\end_inset

 che estrae i picchi più alti
\begin_inset Foot
status open

\begin_layout Plain Layout
Nonchè i più significativi per il sistema in analisi
\end_layout

\end_inset

 dallo spettrogramma.
 Ogni picco è rappresentato da un oggetto 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

Peak
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
i 
\series bold
Links 
\series default
sono il risultato dell'operazione di 
\emph on
fingerprinting
\emph default
, ovvero le features che caratterizzano l'audio.
 Vengono creati a partire dai vari 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

Peak
\end_layout

\end_inset

 estratti da 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

findPeaks
\end_layout

\end_inset

 e fanno parte del namespace 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

core
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Tutte le classi e le funzioni della libreria 
\emph on
fin
\emph default
 sono contenute nel namespace 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

fin
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
La classe Reader e le sue sottoclassi
\end_layout

\begin_layout Standard
La classe 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 generica rappresenta un contenitore di campioni audio.
 Definisce due metodi puri virtuali:
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

getData()
\end_layout

\end_inset

 che ritorna un 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

std::vector<float>
\end_layout

\end_inset

 contenente i campioni
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

dropSamples()
\end_layout

\end_inset

 che svuota il 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

vector
\end_layout

\end_inset

 dei campioni
\end_layout

\begin_layout Standard
\begin_inset Float marginfigure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset External
	template Inkscape
	filename img/readers.svg
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "mar:Ereditarieta-readers"

\end_inset

Schema ereditarietà tra readers
\end_layout

\end_inset


\end_layout

\end_inset

La classe 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 viene estesa da due classi 
\emph on
reader
\emph default
 concrete (vedi figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "mar:Ereditarieta-readers"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

WavReader
\end_layout

\end_inset

, in grado di leggere i file Wave.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

DummyReader
\end_layout

\end_inset

, un mero wrapper attorno al contenitore 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

std::vector
\end_layout

\end_inset

, con un metodo 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

addSamples
\end_layout

\end_inset

 per inserire nuovi samples nel vettore.
\end_layout

\begin_layout Section
Lo spettrogramma
\end_layout

\begin_layout Standard
Lo 
\emph on
spettrogramma
\emph default
 è una rappresentazione tridimensionale del contenuto in frequenza di un
 segnale nel tempo.
 Questa rappresentazione di un segnale audio viene calcolata e memorizzata
 all'interno della classe 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

Spectrogram
\end_layout

\end_inset

 del namespace 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

math
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Il costruttore riceve in input come parametro un 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

std::vector<float>
\end_layout

\end_inset

 di campioni nel dominio del tempo dell'audio da analizzare: il primo passo
 da compiere è 
\emph on
finestrare il segnale
\emph default
.
 
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:La-finestratura"

\end_inset

La finestratura
\end_layout

\begin_layout Standard
\begin_inset Float marginfigure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{axis}[
\end_layout

\begin_layout Plain Layout

		width=
\backslash
textwidth,
\end_layout

\begin_layout Plain Layout

		height=
\backslash
textwidth,
\end_layout

\begin_layout Plain Layout

		domain=0:.08,
\end_layout

\begin_layout Plain Layout

		samples=100,
\end_layout

\begin_layout Plain Layout

		xmin = 0, xmax = .08,
\end_layout

\begin_layout Plain Layout

		ymin =  -2, ymax = 2,
\end_layout

\begin_layout Plain Layout

		grid = major,
\end_layout

\begin_layout Plain Layout

		xlabel = tempo $(s)$,
\end_layout

\begin_layout Plain Layout

		ylabel = ampiezza,
\end_layout

\begin_layout Plain Layout

		axis x line=bottom,
\end_layout

\begin_layout Plain Layout

		axis y line=left
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\backslash
addplot[color=red,mark=x] coordinates { (0,1) (0.02,1) };
\end_layout

\begin_layout Plain Layout

		
\backslash
addplot[color=red,mark=x] coordinates { (0.02,0) (0.1,0) };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\backslash
addplot[
\end_layout

\begin_layout Plain Layout

			color=green,
\end_layout

\begin_layout Plain Layout

			line width=1pt
\end_layout

\begin_layout Plain Layout

		]{
\end_layout

\begin_layout Plain Layout

			sin(deg(pi*120*x))/2 - sin(deg(pi*60*x))/3 - sin(deg(pi*20*x))/6
\end_layout

\begin_layout Plain Layout

		};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
end{axis}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "mar:Finestratura-con-finestra"

\end_inset

Finestratura con finestra rettangolare
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il primo passo per ottenere uno spettrogramma è finestrare il segnale: il
 caso più semplice consiste nel utilizzare una finestra rettangolare come
 indicato in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "mar:Finestratura-con-finestra"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
L'utilizzo di una 
\emph on
funzione finestra
\emph default
, tuttavia, porta al fenomeno dello 
\emph on
spectral leakage
\emph default
, ovvero la comparsa nello spettro di nuove frequenze che non esistono realmente
 nello spettro del segnale audio originale.
 Nello specifico, l'energia di un picco di frequenza confluisce parzialmente
 nelle frequenze vicine (da cui il termine 
\emph on
leakage
\emph default
), 
\emph on
sporcando
\emph default
 la rappresentazione dello spettrogramma.
\end_layout

\begin_layout Standard
Lo 
\emph on
spectral leakage
\emph default
 non può essere del tutto evitato, ma può essere tenuto sotto controllo
 e ridotto utilizzando una funzione finestra più complessa rispetto a quella
 rettangolare.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
La scelta della finestra implica un trade-off tra la 
\emph on
risoluzione spettrale
\emph default
 e il 
\emph on
range dinamico
\emph default
 del sistema.
 Infatti, l'utilizzo di una finestra con banda passante stretta consente
 di ottenere una maggiore risoluzione spettrale, ovvero di distinguere frequenze
 molto vicine tra loro, ma allo stesso tempo comporta una riduzione del
 range dinamico del sistema, ovvero della capacità di distinguere segnali
 di ampiezza molto differente tra loro.
 Al contrario, l'utilizzo di una finestra con banda passante ampia, comporta
 una maggiore sensibilità ai segnali con un ampio range dinamico, ma al
 costo di una riduzione della risoluzione spettrale.
\end_layout

\begin_layout Standard
Inoltre, è importante considerare che la scelta della finestra deve essere
 fatta in base alle specifiche caratteristiche del segnale che si intende
 analizzare, come ad esempio la presenza di rumore o la distribuzione di
 energia spettrale.
 Pertanto, la scelta dev'essere attentamente valutata in base alle esigenze
 specifiche dell'applicazione.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Il vantaggio principale della 
\emph on
finestra rettangolare
\emph default
 è la sua risposta in frequenza piatta, risultando quindi la migliore in
 termini di risoluzione spettrale.
 Tuttavia, la finestra rettangolare ha una bassa attenuazione laterale,
 ovvero non è in grado di attenuare il rumore presente nelle frequenze circostan
ti, il che limita il suo range dinamico.
\end_layout

\begin_layout Standard
Per ovviare a questo problema, sono state sviluppate altre finestre, come
 quelle di 
\emph on
Blackman
\emph default
 e 
\emph on
Hann
\emph default
.
 La finestra di 
\emph on
Hann
\emph default
 è una scelta intermedia tra la finestra
\emph on
 rettangolare
\emph default
 e la finestra di 
\emph on
Blackman
\emph default
.
 Infatti, la finestra di 
\emph on
Hann
\emph default
 presenta una risoluzione spettrale inferiore rispetto alla finestra 
\emph on
rettangolare
\emph default
 ma un range dinamico migliore.
 La finestra di 
\emph on
Blackman
\emph default
, invece, è la scelta migliore in termini di range dinamico, poiché, tra
 quelle citate, è quella che riduce maggiormente la diffusione dell'energia
 in altre frequenze vicine.
 Tuttavia, la sua risoluzione spettrale è la peggiore.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
La scelta della finestra da utilizzare dipende dalle caratteristiche del
 segnale e degli obiettivi dell'analisi.
 In questo caso di studio si avrà a che fare potenzialmente con un segnale
 rumoroso, quindi si è portati ad utilizzare la finestra di 
\emph on
Blackman
\emph default
.
 D'altro canto, però, si deve considerare che, anticipando il contenuto
 dei prossimi paragrafi, l'estrazione dei Links risulta migliore tanto migliore
 è l'analisi in frequenza del segnale e, quindi, si dovrebbe predilgere
 la massima risoluzione spettrale, individuando con precisione le componenti
 di frequenza presenti nel segnale, a discapito del range dinamico.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
begin{axis}[
\end_layout

\begin_layout Plain Layout

	xlabel={SNR ($dB$)},
\end_layout

\begin_layout Plain Layout

	ylabel={Recognition rate},
\end_layout

\begin_layout Plain Layout

	legend pos=south east,
\end_layout

\begin_layout Plain Layout

	width=
\backslash
textwidth,
\end_layout

\begin_layout Plain Layout

	yticklabel={$
\backslash
pgfmathprintnumber{
\backslash
tick}
\backslash
%$},
\end_layout

\begin_layout Plain Layout

	no markers
\end_layout

\begin_layout Plain Layout

]
\end_layout

\begin_layout Plain Layout


\backslash
addplot table [x=db, y=blackman, col sep=comma] {data/windows_success_rate.csv};
\end_layout

\begin_layout Plain Layout


\backslash
addlegendentry{Blackman}
\end_layout

\begin_layout Plain Layout


\backslash
addplot table [x=db, y=hann, col sep=comma] {data/windows_success_rate.csv};
\end_layout

\begin_layout Plain Layout


\backslash
addlegendentry{Hann}
\end_layout

\begin_layout Plain Layout


\backslash
addplot table [x=db, y=rectangular, col sep=comma] {data/windows_success_rate.csv
};
\end_layout

\begin_layout Plain Layout


\backslash
addlegendentry{Rettangolare}
\end_layout

\begin_layout Plain Layout


\backslash
end{axis}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Recognition-rate-in"

\end_inset

Recognition rate in funzione dell SNR per le varie finestre
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

A questo punto risulta necessario valutare 
\emph on
sul campo 
\emph default
le performance di queste finestre.
 Per questo motivo è stato predisposto un 
\emph on
ambiente di test
\emph default
 composto da circa 400 brani di generi molto diversi tra loro
\begin_inset Foot
status open

\begin_layout Plain Layout
I generi inclusi sono stati il metal, il rock, il blues e la musica classica
\end_layout

\end_inset

 e per ognuno di questi brani:
\end_layout

\begin_layout Enumerate
è stato estratto un segmento di pochi secondi.
\end_layout

\begin_layout Enumerate
il segmento è stato distorto, sommando del rumore non bianco e introdocendo
 del clipping.
\end_layout

\begin_layout Enumerate
nota l'energia del segmento del segnale, è stato sommato un rumore per ottenere
 un SNR target.
\end_layout

\begin_layout Standard
Si è quindi fatto variare, per ogni brano, l'SNR tra 
\begin_inset Formula $-40dB$
\end_inset

 e 
\begin_inset Formula $+40dB$
\end_inset

 con passo di 
\begin_inset Formula $1dB$
\end_inset

, per le tre finestre considerate, contando quante volte l'algorimo fosse
 in grado di individuare il brano correttamente: si è ottenuto il grafico
 in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Recognition-rate-in"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Si potrebbe conlcudere, allora, che la finestra 
\emph on
migliore
\emph default
 è quella rettangolare, ma non esiste una finestra "migliore" in assoluto,
 ma solo la finestra più adatta alle specifiche del problema che si vuole
 risolvere.
\end_layout

\begin_layout Standard
Anche se la finestra rettangolare sembra funzionare 
\emph on
meglio
\emph default
 nei test, è importante considerare che gli stessi sono stati effettuati
 in un ambiente di prova artificiale e che il rumore non bianco e il clipping
 introdotti potrebbero non modellare accuratamente una situazione reale.
 Inoltre, i risultati potrebbero dipendere parzialmente dalle caratteristiche
 specifiche dei brani considerati che potrebbero rappresentare un campione
 poco eterogeneo.
\end_layout

\begin_layout Standard
La scelta è pertanto ricaduta sulla finestra di Hann, dato il suo comportamento
 
\emph on
intermedio 
\emph default
tra la finestra rettangolare e quella di Blackman, ottenendo un buon equilibrio
 tra risoluzione spettrale e range dinamico rilevato.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Il segnale audio viene finestrato con un overlap del 
\begin_inset Formula $50\%$
\end_inset

 (vedi figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Audio-windowing-with-overlap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) per due motivi:
\end_layout

\begin_layout Enumerate
Sopperire all'attenuazione agli estremi della finestra introdotti dalla
 funzione finestra di Hann
\end_layout

\begin_layout Enumerate
Analizzare meglio il contenuto in frequenza a cavallo tra due finestre senza
 overlap
\end_layout

\begin_layout Standard

\lang english
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{axis}[
\end_layout

\begin_layout Plain Layout

		grid=major,
\end_layout

\begin_layout Plain Layout

		samples=200,
\end_layout

\begin_layout Plain Layout

		domain=0:10,
\end_layout

\begin_layout Plain Layout

		width=
\backslash
textwidth,
\end_layout

\begin_layout Plain Layout

		height=
\backslash
axisdefaultheight,
\end_layout

\begin_layout Plain Layout

		xmin = 0, xmax = 10,
\end_layout

\begin_layout Plain Layout

		ymin = -1, ymax = 1,
\end_layout

\begin_layout Plain Layout

		xlabel = tempo $(s)$,
\end_layout

\begin_layout Plain Layout

		ylabel = ampiezza
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\backslash
draw [red, very thick, fill=red, fill opacity=0.2] (0,0) rectangle (10,200);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw [red, very thick, fill=red, fill opacity=0.2] (10,0) rectangle (20,200);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw [red, very thick, fill=red, fill opacity=0.2] (20,0) rectangle (30,200);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw [red, very thick, fill=red, fill opacity=0.2] (30,0) rectangle (40,200);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw [red, very thick, fill=red, fill opacity=0.2] (40,0) rectangle (50,200);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw [red, very thick, fill=red, fill opacity=0.2] (50,0) rectangle (60,200);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw [red, very thick, fill=red, fill opacity=0.2] (60,0) rectangle (70,200);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw [red, very thick, fill=red, fill opacity=0.2] (70,0) rectangle (80,200);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw [red, very thick, fill=red, fill opacity=0.2] (80,0) rectangle (90,200);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw [red, very thick, fill=red, fill opacity=0.2] (90,0) rectangle (100,200);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\backslash
draw [green, fill=green, fill opacity=0.2] (5,0) rectangle (15,200);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw [green, fill=green, fill opacity=0.2] (15,0) rectangle (25,200);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw [green, fill=green, fill opacity=0.2] (25,0) rectangle (35,200);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw [green, fill=green, fill opacity=0.2] (35,0) rectangle (45,200);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw [green, fill=green, fill opacity=0.2] (45,0) rectangle (55,200);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw [green, fill=green, fill opacity=0.2] (55,0) rectangle (65,200);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw [green, fill=green, fill opacity=0.2] (65,0) rectangle (75,200);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw [green, fill=green, fill opacity=0.2] (75,0) rectangle (85,200);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw [green, fill=green, fill opacity=0.2] (85,0) rectangle (95,200);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\backslash
addplot[
\end_layout

\begin_layout Plain Layout

			blue,
\end_layout

\begin_layout Plain Layout

			smooth
\end_layout

\begin_layout Plain Layout

		]
\end_layout

\begin_layout Plain Layout

		{(0.3*gauss(0,0.2) + 0.5*rand) * sin(deg(x)) * 2};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
end{axis}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
\begin_inset Caption Standard

\begin_layout Plain Layout

\lang english
\begin_inset CommandInset label
LatexCommand label
name "fig:Audio-windowing-with-overlap"

\end_inset

Finestratura audio con overlap
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
La DFT
\end_layout

\begin_layout Standard
La 
\emph on
trasformata di Fourier discreta 
\emph default
viene calcolata facendo ricorso alla libreria 
\series bold
fftw
\series default

\begin_inset Foot
status open

\begin_layout Plain Layout
Reperibile all'indirizzo 
\begin_inset CommandInset href
LatexCommand href
name "https://www.fftw.org/"
target "https://www.fftw.org/"
literal "false"

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In prima analisi è necessario introdurre il concetto di 
\emph on
risoluzione spettrale, 
\emph default
ossia la capacità di un'analisi spettrale di distinguere due componenti
 di frequenza vicine nel dominio della frequenza.
 Dipende dal numero di campioni utilizzati nella finestra e dalla finestra
 utilizzata
\begin_inset Foot
status open

\begin_layout Plain Layout
Vedere paragrafo 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:La-finestratura"
plural "false"
caps "false"
noprefix "false"

\end_inset

 sulla risoluzione spettrale delle finestre
\end_layout

\end_inset

.
 La 
\emph on
risoluzione in frequenza
\emph default
 della DFT può essere calcolata come segue:
\begin_inset Formula 
\[
\Delta f=\frac{F_{S}}{N}
\]

\end_inset

Dove:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Delta f$
\end_inset

 è la 
\emph on
risoluzione spettrale
\emph default
, anche detta 
\emph on
dimensione del bin di frequenze
\end_layout

\begin_layout Itemize
\begin_inset Formula $F_{S}$
\end_inset

 è la 
\emph on
frequenza di campionamento
\end_layout

\begin_layout Itemize
\begin_inset Formula $N$
\end_inset

 sono il numero di campioni in una finestra
\end_layout

\begin_layout Standard
La libreria fin è configurata per trattare segnali audio campionati a 
\begin_inset Formula $8000Hz$
\end_inset

, utilizzando finestre di dimensione pari a 
\begin_inset Formula $512$
\end_inset

 campioni
\begin_inset Foot
status open

\begin_layout Plain Layout
Successivamente verranno fatte delle considerazioni su queste scelte
\end_layout

\end_inset

, quindi:
\begin_inset Formula 
\[
\Delta f=\frac{8000Hz}{512}=15.625Hz
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\noindent
Inoltre, è necessario fare alcune osservazioni aggiuntive:
\end_layout

\begin_layout Enumerate
Il primo bin non contiene informazioni rilevanti riguardo la rappresentazione
 in frequenza del segnale
\end_layout

\begin_layout Enumerate
L'output della DFT su segnali reali è simmetrico
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

A dimostrazione del primo fatto si può partire dalla definizione della DFT:
\begin_inset Formula 
\begin{equation}
\begin{aligned}X[n]:= & \sum_{t=0}^{N-1}x(t)e^{-i\frac{2\pi tn}{N}}\end{aligned}
\label{eq:def_dft}
\end{equation}

\end_inset

e valutarla in 
\begin_inset Formula $n=0$
\end_inset

:
\begin_inset Formula 
\[
\begin{aligned}X[n]|_{n=0}:= & \sum_{t=0}^{N-1}x(t)e^{-i\frac{2\pi tn}{N}}|_{n=0}\\
= & \sum_{t=0}^{N-1}x(t)e^{0}\\
= & \sum_{t=0}^{N-1}x(t)
\end{aligned}
\]

\end_inset

In altre parole, il primo bin dell'output della DFT corrisponde alla 
\emph on
componente DC 
\emph default
del segnale in ingresso che può assunto pari a 
\begin_inset Formula $0$
\end_inset

 e quindi ignorato nel caso di segnali audio.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Per quanto riguarda il secondo fatto, si deve dimostrare che se 
\begin_inset Formula $x(t)$
\end_inset

 è un segnale a valori reali allora:
\begin_inset Formula 
\begin{equation}
X[N-n]=X^{*}[n]\label{eq:simmetria_dft}
\end{equation}

\end_inset

dove:
\end_layout

\begin_layout Itemize
\begin_inset Formula $X(\astrosun)$
\end_inset

 è l'output della DFT applicata a 
\begin_inset Formula $x(t)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $(\astrosun)^{*}$
\end_inset

 denota il coniugato di 
\begin_inset Formula $\astrosun$
\end_inset

 
\end_layout

\begin_layout Standard
Si sostituisce 
\begin_inset Formula $n$
\end_inset

 con 
\begin_inset Formula $N-n$
\end_inset

 nella definizione della DFT 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def_dft"
plural "false"
caps "false"
noprefix "false"

\end_inset

, proveniente dalla 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:simmetria_dft"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset Formula 
\[
\begin{aligned}X[N-n]:= & \sum_{t=0}^{N-1}x(t)e^{-i\frac{2\pi t(N-n)}{N}}\\
= & \sum_{t=0}^{N-1}x(t)\underbrace{e^{-i2\pi t}}_{1\forall t}e^{i\frac{2\pi tn}{N}}\\
= & \sum_{t=0}^{N-1}x(t)e^{i\frac{2\pi tn}{N}}\\
= & \left(\sum_{t=0}^{N-1}x(t)e^{-i\frac{2\pi tn}{N}}\right)^{*}\\
= & X^{*}[n]
\end{aligned}
\]

\end_inset

Dove il passaggio al coniugato è invariante per 
\begin_inset Formula $x(t)$
\end_inset

 dato che è a valori reali.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Le due precedenti considerazioni permettono quindi all'algoritmo di lavorare
 in maniera più efficiente, escludendo la componente DC dai calcoli ed impiegand
o una versione ottimizzata della DFT per input reali, con soli 
\begin_inset Formula $\frac{N}{2}-1$
\end_inset

 coefficienti utili in output.
\end_layout

\begin_layout Subsection
Il modulo dello spettrogramma e le 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

fftWindow
\end_layout

\end_inset

s
\end_layout

\begin_layout Standard
L'output della DFT è un vettore di 
\begin_inset Formula $\frac{N}{2}-1$
\end_inset

 numeri complessi, ma l'algoritmo necessita solo del loro modulo in 
\begin_inset Formula $dB$
\end_inset

, calcolato come:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
20\log_{10}\sqrt{a^{2}+b^{2}}=10\log_{10}\left(a^{2}+b^{2}\right)
\]

\end_inset

Dove 
\begin_inset Formula $a$
\end_inset

 e 
\begin_inset Formula $b$
\end_inset

 sono rispettivamente la parte reale e immaginaria del numero complesso.
\end_layout

\begin_layout Standard
I vari moduli, per ogni finestra considerata, vengono memorizzati all'interno
 di un oggetto 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

fftWindow
\end_layout

\end_inset

.
 Ogni 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

fftWindow
\end_layout

\end_inset

 viene inserita in un 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

std::vector
\end_layout

\end_inset

 che verrà utilizzato dalla funzione 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

findPeaks
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
I Peaks
\end_layout

\begin_layout Standard
Pronto lo spettrogramma lo si deve processare per ottenere i picchi di frequeze
 più significativi e scartare tutto il resto: questo permette di avere una
 prima rappresentazione più combatta del segnale audio.
\end_layout

\begin_layout Standard
Lo spettrogramma è diviso in una sorta di griglia, in cui ogni cella ha
 le seguenti dimensioni:
\end_layout

\begin_layout Itemize
Larghezza pari a 
\begin_inset Formula $C$
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Definita nel file 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

consts.h
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Altezza pari ad un range di frequenze, chiamato 
\emph on
banda
\end_layout

\begin_layout Standard

\lang english
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{axis}[
\end_layout

\begin_layout Plain Layout

		grid=major,
\end_layout

\begin_layout Plain Layout

		width=
\backslash
textwidth,
\end_layout

\begin_layout Plain Layout

		height=
\backslash
axisdefaultheight,
\end_layout

\begin_layout Plain Layout

		xlabel = Tempo $(s)$,
\end_layout

\begin_layout Plain Layout

		ylabel = Frequenza $(Hz)$,
\end_layout

\begin_layout Plain Layout

		xmin = 0, xmax = 13,
\end_layout

\begin_layout Plain Layout

		ymin = 0, ymax = 4000,
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		
\backslash
draw[pattern=north west lines, pattern color=blue, line width=1pt] (0,0)
 rectangle (40,100);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw[pattern=north east lines, pattern color=blue, line width=1pt] (40,0)
 rectangle (80,100);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw[pattern=north west lines, pattern color=blue, line width=1pt] (80,0)
 rectangle (120,100);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\backslash
draw[pattern=north east lines, pattern color=green, line width=1pt] (0,100)
 rectangle (40,200);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw[pattern=north west lines, pattern color=green, line width=1pt] (40,100)
 rectangle (80,200);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw[pattern=north east lines, pattern color=green, line width=1pt] (80,100)
 rectangle (120,200);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\backslash
draw[pattern=north west lines, pattern color=red, line width=1pt] (0,200)
 rectangle (40,300);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw[pattern=north east lines, pattern color=red, line width=1pt] (40,200)
 rectangle (80,300);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw[pattern=north west lines, pattern color=red, line width=1pt] (80,200)
 rectangle (120,300);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\backslash
draw[pattern=north east lines, pattern color=orange, line width=1pt] (0,300)
 rectangle (40,400);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw[pattern=north west lines, pattern color=orange, line width=1pt] (40,300)
 rectangle (80,400);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw[pattern=north east lines, pattern color=orange, line width=1pt] (80,300)
 rectangle (120,400);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	
\backslash
end{axis}
\end_layout

\begin_layout Plain Layout

	
\backslash
draw[decoration={brace,mirror,raise=15pt},decorate]   (0,0) -- node[below=16pt]
 {
\backslash
textbf{C}} (2.9,0);
\end_layout

\begin_layout Plain Layout

	
\backslash
draw[decoration={brace,mirror},decorate]   (9.7,0) -- node[xshift=10pt] {
\backslash
rotatebox{-90}{
\backslash
textbf{banda}}} (9.7,1.4);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
\begin_inset Caption Standard

\begin_layout Plain Layout

\lang english
\begin_inset CommandInset label
LatexCommand label
name "fig:Spectrum-division"

\end_inset

Suddivisione dello spettro (ogni colore è una banda)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Si prenda la suddivisione semplificata della figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Spectrum-division"
plural "false"
caps "false"
noprefix "false"

\end_inset

 dove:
\end_layout

\begin_layout Itemize
\begin_inset Formula $C=4$
\end_inset


\end_layout

\begin_layout Itemize
La banda ha dimensione fissa pari a 
\begin_inset Formula $100Hz$
\end_inset


\end_layout

\begin_layout Standard
Nell'algoritmo questi parametri sono scelti diversamente: 
\begin_inset Formula $C$
\end_inset

 è uguale a 
\begin_inset Formula $32$
\end_inset

 e la suddivisione in bande segue una scala logaritmica (vedere 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Scelta-della-dimensione"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
Per ogni cella, attraverso la funzione 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

findPeaksInWindow
\end_layout

\end_inset

 definita nel file 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

peaks_finder.cpp
\end_layout

\end_inset

, l'algoritmo individua e memorizza le 
\begin_inset Formula $3$
\end_inset

 frequenze
\begin_inset Foot
status open

\begin_layout Plain Layout
Costante 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

N_PEAKS
\end_layout

\end_inset

 in 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

consts.h
\end_layout

\end_inset


\end_layout

\end_inset

 più prominenti.
\end_layout

\begin_layout Standard

\lang english
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{axis}[
\end_layout

\begin_layout Plain Layout

		grid=major,
\end_layout

\begin_layout Plain Layout

		width=
\backslash
textwidth,
\end_layout

\begin_layout Plain Layout

		height=
\backslash
axisdefaultheight,
\end_layout

\begin_layout Plain Layout

		xlabel = Tempo $(s)$,
\end_layout

\begin_layout Plain Layout

		ylabel = Frequenza $(Hz)$,
\end_layout

\begin_layout Plain Layout

		xmin = 0, xmax = 13,
\end_layout

\begin_layout Plain Layout

		ymin = 0, ymax = 4000,
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		
\backslash
draw[blue, line width=1pt] (0,0) rectangle (40,100);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw[blue, line width=1pt] (40,0) rectangle (80,100);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw[blue, line width=1pt] (80,0) rectangle (120,100);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\backslash
draw[green, line width=1pt] (0,100) rectangle (40,200);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw[green, line width=1pt] (40,100) rectangle (80,200);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw[green, line width=1pt] (80,100) rectangle (120,200);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\backslash
draw[red, line width=1pt] (0,200) rectangle (40,300);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw[red, line width=1pt] (40,200) rectangle (80,300);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw[red, line width=1pt] (80,200) rectangle (120,300);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\backslash
draw[orange, line width=1pt] (0,300) rectangle (40,400);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw[orange, line width=1pt] (40,300) rectangle (80,400);
\end_layout

\begin_layout Plain Layout

		
\backslash
draw[orange, line width=1pt] (80,300) rectangle (120,400);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		
\backslash
addplot [ blue ,only marks,mark=star] coordinates { ( 0.745560224337 , 378.5992651
97 ) }; 
\backslash
addplot [ blue ,only marks,mark=star] coordinates { ( 3.35149848633 , 885.69642912
8 ) }; 
\backslash
addplot [ blue ,only marks,mark=star] coordinates { ( 1.36552968092 , 687.79506248
 ) }; 
\backslash
addplot [ green ,only marks,mark=star] coordinates { ( 3.73052621593 , 1521.618562
76 ) }; 
\backslash
addplot [ green ,only marks,mark=star] coordinates { ( 2.24021149438 , 1286.762539
77 ) }; 
\backslash
addplot [ green ,only marks,mark=star] coordinates { ( 2.31025446998 , 1759.585072
66 ) }; 
\backslash
addplot [ red ,only marks,mark=star] coordinates { ( 0.367038182557 , 2640.0077863
8 ) }; 
\backslash
addplot [ red ,only marks,mark=star] coordinates { ( 2.60223704132 , 2543.51959691
 ) }; 
\backslash
addplot [ red ,only marks,mark=star] coordinates { ( 3.29030455474 , 2857.42356211
 ) }; 
\backslash
addplot [ orange ,only marks,mark=star] coordinates { ( 3.06012887649 , 3859.57073
579 ) }; 
\backslash
addplot [ orange ,only marks,mark=star] coordinates { ( 1.04281482521 , 3310.98256
132 ) }; 
\backslash
addplot [ orange ,only marks,mark=star] coordinates { ( 0.342092598793 ,
 3187.00295803 ) }; 
\backslash
addplot [ blue ,only marks,mark=star] coordinates { ( 6.13965840628 , 346.37314184
4 ) }; 
\backslash
addplot [ blue ,only marks,mark=star] coordinates { ( 6.18220033666 , 151.14467838
3 ) }; 
\backslash
addplot [ blue ,only marks,mark=star] coordinates { ( 5.10152863505 , 640.55570001
8 ) }; 
\backslash
addplot [ green ,only marks,mark=star] coordinates { ( 6.25598325224 , 1797.769092
61 ) }; 
\backslash
addplot [ green ,only marks,mark=star] coordinates { ( 7.08091233708 , 1668.626795
36 ) }; 
\backslash
addplot [ green ,only marks,mark=star] coordinates { ( 5.30064456137 , 1131.850638
39 ) }; 
\backslash
addplot [ red ,only marks,mark=star] coordinates { ( 7.2544573697 , 2751.61392809
 ) }; 
\backslash
addplot [ red ,only marks,mark=star] coordinates { ( 6.8872104256 , 2267.19959314
 ) }; 
\backslash
addplot [ red ,only marks,mark=star] coordinates { ( 7.45001350539 , 2289.19953153
 ) }; 
\backslash
addplot [ orange ,only marks,mark=star] coordinates { ( 5.64148867695 , 3139.99246
694 ) }; 
\backslash
addplot [ orange ,only marks,mark=star] coordinates { ( 5.80868333293 , 3160.84633
384 ) }; 
\backslash
addplot [ orange ,only marks,mark=star] coordinates { ( 4.68927142292 , 3263.16366
007 ) }; 
\backslash
addplot [ blue ,only marks,mark=star] coordinates { ( 8.50986878705 , 653.82012721
1 ) }; 
\backslash
addplot [ blue ,only marks,mark=star] coordinates { ( 8.94884609281 , 539.46336189
3 ) }; 
\backslash
addplot [ blue ,only marks,mark=star] coordinates { ( 8.44637953657 , 707.94351178
6 ) }; 
\backslash
addplot [ green ,only marks,mark=star] coordinates { ( 9.49315824083 , 1563.597638
99 ) }; 
\backslash
addplot [ green ,only marks,mark=star] coordinates { ( 9.74759745215 , 1888.112335
31 ) }; 
\backslash
addplot [ green ,only marks,mark=star] coordinates { ( 10.7844077137 , 1477.871231
18 ) }; 
\backslash
addplot [ red ,only marks,mark=star] coordinates { ( 8.899479235 , 2856.56308609
 ) }; 
\backslash
addplot [ red ,only marks,mark=star] coordinates { ( 9.50730112412 , 2796.10602412
 ) }; 
\backslash
addplot [ red ,only marks,mark=star] coordinates { ( 11.6806723738 , 2173.69277417
 ) }; 
\backslash
addplot [ orange ,only marks,mark=star] coordinates { ( 9.28333255686 , 3800.01058
487 ) }; 
\backslash
addplot [ orange ,only marks,mark=star] coordinates { ( 9.87529616782 , 3162.85741
608 ) }; 
\backslash
addplot [ orange ,only marks,mark=star] coordinates { ( 10.5805497799 , 3704.10829
642 ) }; 
\end_layout

\begin_layout Plain Layout

	
\backslash
end{axis}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
\begin_inset Caption Standard

\begin_layout Plain Layout

\lang english
\begin_inset CommandInset label
LatexCommand label
name "fig:Three-points-per"

\end_inset

Spettrogramma con 
\begin_inset Formula $3$
\end_inset

 picchi per cella
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La funzione 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

findPeaks
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Sempre in 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

peaks_finder.cpp
\end_layout

\end_inset


\end_layout

\end_inset

 si occupa di divedere lo spettro in celle, per ogni cella richiama 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

findPeaksInWindow
\end_layout

\end_inset

 e ne memorizza il risultato, ottenendo qualcosa di simile a quanto visibile
 in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Three-points-per"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Alla fine dell'esecuzione di 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

findPeaks
\end_layout

\end_inset

 sarà disponibile un 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

std::vector<Peak>
\end_layout

\end_inset

 ordinato per intensità del picco.
 Questi picchi verrano utilizzati in seguito per creare i 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

Link
\end_layout

\end_inset

s.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Scelta-della-dimensione"

\end_inset

Scelta della dimensione delle bande
\end_layout

\end_body
\end_document
