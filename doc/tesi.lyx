#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass tufte-book
\begin_preamble
\usepackage{pgfplots}
\setcounter{tocdepth}{2}
\setcounter{secnumdepth}{2}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style french
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
title[Identificazione audio resistente al rumote in WebAssembly]{
\end_layout

\begin_layout Plain Layout

  
\backslash
mbox{Identificazione} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\backslash
mbox{audio resistente} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\backslash
mbox{al rumore} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\backslash
mbox{in WebAssembly}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Author
Davide Pisanò - Antonio Servetti
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduzione
\end_layout

\begin_layout Standard
Negli ultimi anni si è notato un trend sempre crescente nell'utilizzo di
 JavaScript per la creazione di applicazioni desktop.
\end_layout

\begin_layout Standard
Ci sono diversi fattori che hanno contribuito alla popolarità di JavaScript,
 primo fra tutti è che rappresenta il linguaggio standard, de facto, per
 l'implementazione di funzionalità dinamiche su pagine web.
 Nello specifico, JavaScript è l'unico linguaggio di scripting supportato
 nativamente da tutti i browser web moderni.
\end_layout

\begin_layout Standard
Ci sono stati dei tentativi per introdurre alcune novità in questo ambito,
 seguendo principalmente due approcci:
\end_layout

\begin_layout Enumerate
l'inclusione di una nuova macchina virtuale all'interno di un browser web
 che supportasse un nuovo linguaggio
\end_layout

\begin_layout Enumerate
la realizzazione di un nuovo linguaggio ma eseguito sulla stessa macchina
 virtuale JavaScript già presente in un web browser
\end_layout

\begin_layout Standard
Ricade nella prima categoria VBScript di Microsoft, basato su Visual Basic,
 introdotto a metà degli anni '90, oggi non più supportato da nessun browser
 moderno.
\end_layout

\begin_layout Standard
Nella seconda categoria possiamo annoverare, più recentemente, TypeScript
 (sempre di Microsoft), CoffeeScript e Dart (di Google).
 Questi linguaggi sono basati su un cosiddetto 
\emph on
transpiler
\emph default
, ovvero un compilatore che prende in input il codice sorgente scritto ad
 esempio in TypeScript e lo converte in codice JavaScript, mantenendo le
 stesse funzionalità del codice originale.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

Un altro punto di forza di JavaScript è la sua facilità di apprendimento,
 soprattutto rispetto ad altri linguaggi di programmazione più a basso livello
 come C o C++, permettendo agli sviluppatori di iniziare a scrivere codice
 più rapidamente, senza dover investire troppo tempo nell'apprendimento
 di una nuova tecnologia.
 Oggi, infatti, si assiste ad una quantità sempre crescente di librerie
 e framework per JavaScript, atti a semplificare lo sviluppo di applicazioni
 web complesse e a migliorarne la qualità, giusto per citarne alcuni: React,
 Angular, Vue.js, ma anche il più 
\begin_inset Quotes eld
\end_inset

anziano
\begin_inset Quotes erd
\end_inset

 jQuery.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Per questi ed altri motivi, durante la fine degli anni 2000, ci si è iniziati
 a porre una domanda: 
\begin_inset Quotes eld
\end_inset

è possibile eseguire codice JavaScript al di fuori del contesto web browser?
\begin_inset Quotes erd
\end_inset

.
 La risposta (affermativa) a questa domanda è stata la nascita di Node.js
 che ha dato il via al paradigma del 
\emph on
JavaScript everywhere
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
Del quale non mancano i detrattori
\end_layout

\end_inset

.
 Questo vuol dire, in estrema sintesi, poter utilizzare lo stesso linguaggio
 per creare applicazioni web, sia lato front-end sia lato back-end.
 In teoria si potrebbe così ridurre il tempo necessario per il processo
 di sviluppo di un'applicazione, riducendo il portfolio di tecnologie che
 un programmatore deve conoscere.
\end_layout

\begin_layout Standard
Nei primi anni 2010, quando Node.js iniziava a prendere piede, ci si è posti
 un'altra domanda 
\begin_inset Quotes eld
\end_inset

è possibile scrivere e distribuire applicazioni desktop/mobile scritte in
 JavaScript?
\begin_inset Quotes erd
\end_inset

.
 La risposta, ancora una volta, è stata affermativa.
 Nasce Electron: un framework open-source che consente agli sviluppatori
 di creare applicazioni desktop multi-piattaforma utilizzando tecnologie
 web standard come HTML, CSS e JavaScript.
 Dal lato mobile nascono tecnologie analoghe a Electron come Ionic, React
 Native e PhoneGap, tutte con obiettivi abbastanza simili.
 Man mano l'ecosistema JavaScript ha iniziato a diventare quello che Java
 era nei primi anni 2000 per la scrittura di applicazioni desktop consumer
 multipiattaforma.
\end_layout

\begin_layout Standard
Il motivo principale dietro alla popolarità di questo ecosistema basato
 su JavaScript è la possibilità di utilizzare un'unica codebase (in JavaScript)
 che può essere eseguita su piattaforme molto diverse tra loro, problematica
 che è molto sentita nell'ambito mobile dove si hanno due piattaforme completame
nte diverse: Android e iOS
\begin_inset Foot
status open

\begin_layout Plain Layout
All'epoca della prima apparizione di queste tecnologie bisognava supportare
 anche Windows Phone
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Il trend di scrivere applicazioni in JavaScript è stato amplificato dalla
 crescente importanza del web come piattaforma per la distribuzione di applicazi
oni software.
 Software utilizzati quotidianamente da miliardi di utenti sono basati sul
 web e, per forza di cose, devono essere scritti in JavaScript.
\end_layout

\begin_layout Standard
Da qui la nascita delle cosiddette 
\emph on
Rich Internet Applications
\emph default
 (RIA), ovvero applicazioni web che offrono un'esperienza utente interattiva
 e avanzata simile a quella di un'applicazione desktop tradizionale.
 Le RIA sono caratterizzate da una vasta gamma di funzionalità e interattività
 che le distinguono dalla semplici pagine web statiche.
 Oltre alla classica triade HTML + CSS + JavaScript le RIA possono fare
 uso di tecnologie più avanzate e recenti come WebSockets, WebAudio, WebAssembly
, WebRTC, WebVR, WebGPU, Web Animations API.
 In sostanza il browser diventa un'interfaccia o un'astrazione della macchina
 sottostante, alla quale si può accedere utilizzando JavaScript.
\end_layout

\begin_layout Standard
Nello specifico WebAudio è un'API JavaScript avanzata che consente di manipolare
 e generare audio all'interno del browser.
 È stata progettata per consentire agli sviluppatori di creare RIA che includono
 funzionalità audio, come la registrazione, la riproduzione e l'elaborazione
 di suoni.
 L'API è basata su un'architettura a nodi, dove ogni nodo rappresenta una
 singola operazione di elaborazione del suono.
 I nodi possono essere collegati tra loro per creare una catena di elaborazione,
 in cui il suono viene elaborato in successione da ogni nodo che attraversa.
 La manipolazione del suono avviene in real time.
 WebAudio è oggi supportato su tutti i browser recenti basati sugli engine
 JavaScript V8 e SpiderMonkey.
\end_layout

\begin_layout Standard
La necessità di scrivere applicazioni real time ha portato la necessità
 di dover eseguire codice ad alta efficienza, obiettivo non realizzabile
 completamente con un linguaggio interpretato quale JavaScript.
 Alla fine degli anni 2010 nasce quindi 
\emph on
WebAssembly
\emph default
 (Wasm): un formato di codice binario portabile che consente di eseguire
 codice di basso livello all'interno del browser web.
 È stato progettato per essere compatibile con i linguaggi di programmazione
 come C, C++ e Rust.
 In pratica, quindi, Wasm permette di creare applicazioni web che eseguono
 codice più velocemente e con maggiore efficienza rispetto a soluzioni basate
 su JavaScript.
 Wasm è stato pensato per essere altamente interoperabile con JavaScript:
 codice JavaScript può richiamare codice Wasm e viceversa, creando quindi
 soluzioni ibride che combinano il meglio di entrambi i mondi.
\end_layout

\begin_layout Standard
Sfruttando tutte queste tecnologie e un ecosistema ormai maturo, l'obiettivo
 di questa tesi è quello di discutere la realizzazione di un sistema per
 l'identificazione di audio: un utente sottopone uno spezzone di un brano
 audio di pochi secondi al sistema, il quale risponde col nome di quel brano.
 L'obiettivo principale è quello di eseguire l'algoritmo di identificazione
 su dispositivi eterogenei all'interno di un web browser, utilizzando Wasm
 e WebAudio.
 Questo presenta numerosi vantaggi, tra i più importanti si possono individuare:
\end_layout

\begin_layout Itemize
l'evitare all'utente il download di un'app addizionale, potendo sfruttare
 le funzionalità dell'algoritmo di riconoscimento direttamente dal suo web
 browser
\end_layout

\begin_layout Itemize
la notevole riduzione del carico lato server: grazie alla sua architettura
 distribuita, parte della complessità viene spostata sul dispositivo dell'utente
 finale, il quale porta a termine buona parte del processo di identificazione,
 rendendo possibile un'identificazione più veloce ed efficiente rispetto
 ad altre applicazioni simili
\end_layout

\begin_layout Standard
In definitiva, si renderà l'esperienza dell'utente ancora più piacevole
 e soddisfacente, mantenendo le stesse funzionalità e caratteristiche di
 una classica app eseguita nativamente su un dispositivo dell'utente.
\end_layout

\begin_layout Section
Architettura generale
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset External
	template Inkscape
	filename img/architettura_generale.svg
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Schema-architettura-generale"

\end_inset

Schema architettura generale
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'architettura di base del sistema (in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Schema-architettura-generale"
plural "false"
caps "false"
noprefix "false"

\end_inset

), seppur ispirata al modello client/server, si discosta dalla tradizionale
 asimmetria tra i due attori, in cui il primo agisce come mero terminale
 passivo
\begin_inset Foot
status open

\begin_layout Plain Layout
In gergo tecnico è ciò che si definisce 
\emph on
dumb terminal
\end_layout

\end_inset

, limitandosi a interagire con l'API del server.
 La nuova soluzione adottata, invece, si propone di spostare parte della
 logica di business dal server al client, in un'ottica distribuita che avvicina
 la computazione all'utente e alleggerisce, al contempo, il carico sul server
 centrale, riducendo così i costi correlati.
 Tale approccio innovativo sfrutta le risorse disponibili sui dispositivi
 dell'utente, aumentando la scalabilità del sistema e garantendo prestazioni
 elevate e una maggiore efficienza.
 Questa soluzione rappresenta un notevole passo avanti nella progettazione
 di applicazioni web avanzate, fornendo un'esperienza utente fluida e gradevole.
\end_layout

\begin_layout Subsection
Scomposizione dell'architettura
\end_layout

\begin_layout Standard
\noindent
L'architettura (in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Schema-architettura-generale"
plural "false"
caps "false"
noprefix "false"

\end_inset

) può essere scomposta come segue:
\end_layout

\begin_layout Enumerate
Si inizia dai brani originali, la canzone nella sua interezza, salvata su
 una memoria di massa.
 La canzone è sottoposta ad una algoritmo di 
\emph on
fingerprinting
\emph default
, in cui vengono estratte alcune features
\begin_inset Foot
status open

\begin_layout Plain Layout
In seguito queste features prenderanno il nome di 
\emph on
Links
\end_layout

\end_inset

 caratterizzanti.
\end_layout

\begin_layout Enumerate
Le features estratte vengono memorizzate all'interno di un database insieme
 al nome della canzone alla quale appartengono.
\end_layout

\begin_layout Enumerate
Si immagini quindi che, ad un certo punto, un client voglia avviare il processo
 di riconoscimento di un brano: viene registrato uno spezzone audio di pochi
 secondi e viene innescata la stessa procedura di 
\emph on
fingerprinting
\emph default
 al punto 1 sul client, ma in questo caso le features estratte vengono inviate
 ad un endpoint REST.
\end_layout

\begin_layout Enumerate
Il server REST cerca di individuare delle similarità tra le features già
 presenti nel database e quelle appena inviategli dal client.
\end_layout

\begin_layout Enumerate
Se la ricerca ha successo, il server REST estrae dal database il nome della
 corrispondenza migliore.
\end_layout

\begin_layout Enumerate
Se la ricerca ha successo, il server REST invia al client il nome della
 corrispondenza migliore.
\end_layout

\begin_layout Standard
Si noti, anzitutto, che la parte più intensiva dal punto di vista computazionale
 è l'estrazione delle features, al contrario la ricerca delle similarità,
 sebbene impegnativa, non lo è quanto l'estrazione delle features stesse
\begin_inset Foot
status open

\begin_layout Plain Layout
Ulteriori considerazioni sull'argomento verranno fatte in seguito
\end_layout

\end_inset

.
 In altre parole, il momento di maggior carico computazionale si verifica
 in due fasi:
\end_layout

\begin_layout Itemize

\emph on
Lato server
\emph default
: solo nella fase iniziale che porta al popolamento del database, durante
 l'analisi dei brani originali (ovvero fasi 1 e 2)
\end_layout

\begin_layout Itemize

\emph on
Lato client
\emph default
: nell'estrazione delle features della registrazione del brano da riconoscere
\end_layout

\begin_layout Standard
In altre parole, l'operazione più onerosa per il server viene eseguita una
 sola volta: all'atto del fingerprinting dei brani originali.
 Sarà poi il client a farsi carico dell'operazione di fingerprinting per
 l'identificazione del singolo brano.
\end_layout

\begin_layout Standard
Il server REST ha una duplice funzione:
\end_layout

\begin_layout Itemize
Presentare i dati nel formato corretto sia lato client che lato database,
 fungendo quindi da una sorta di relay e disaccoppiando la rappresentazione
 interna dei dati a quella esposta al client
\end_layout

\begin_layout Itemize
Individuare similarità con le features già presenti nel database
\end_layout

\begin_layout Standard
L'intero sistema verrà descritto in modo più dettagliato nei capitoli successivi.
\end_layout

\begin_layout Section
Organizzazione del codice
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset External
	template Inkscape
	filename img/organizzazione_codice.svg
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Organizzazione-codice"

\end_inset

Schema organizzazione codice
\end_layout

\end_inset


\end_layout

\end_inset

Il codice sorgente del sistema è suddiviso nei seguenti componenti (figura
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Organizzazione-codice"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\end_layout

\begin_layout Itemize
La libreria 
\emph on
fin
\emph default
, deputata all'estrazione delle features (ovvero fare 
\emph on
fingerprinting
\emph default
) dei brani in esame.
\end_layout

\begin_layout Itemize
La libreria 
\emph on
fin_db
\emph default
 preposta all'interazione con il database, svolgendo i compiti di inserimento
 e ricerca delle features.
 Dipende da 
\emph on
fin
\emph default
.
\end_layout

\begin_layout Itemize
L'eseguibile 
\emph on
mock_client
\emph default
, riservato esclusivamente ad attività di testing, il quale riceve in input
 un segmento noto di un brano, al fine di verificare la corretta identificazione
 del brano stesso.
 Dipende da entrambe le librerie.
\end_layout

\begin_layout Itemize
L'eseguibile 
\emph on
server_entry
\emph default
,
\emph on
 
\emph default
in grado di elaborare i brani completi per estrarne le features, per poi
 memorizzarle nel database insieme al nome del brano associato
\end_layout

\begin_layout Itemize
L'eseguibile
\emph on
 server_rest
\emph default
 che espone l'endpoint REST per l'individuazione dei brani: riceve le features
 del segmento audio estratte dal client, effettua una ricerca di un brano
 compatibile all'interno del database e, in caso di esito positivo, restituisce
 al client il nome del brano individuato.
 Dipende da entrambe le librerie.
\end_layout

\begin_layout Itemize
L'eseguibile
\begin_inset Foot
status open

\begin_layout Plain Layout
In realtà l'eseguibile è la RIA, contenente HTML, il modulo Wasm e il codice
 JavaScript necessario al caricamento del modulo Wasm
\end_layout

\end_inset

 
\emph on
wasm
\emph default
, ovvero il client, in grado di acquisire il segmento audio tramite microfono
 del client, estraendone le features per poi inviarle a 
\emph on
server_rest
\emph default
.
\end_layout

\begin_layout Standard
Successivamente, nei prossimi capitoli, verranno esaminate in dettaglio
 le specifiche funzionalità di ciascun componente sopracitato.
\end_layout

\begin_layout Chapter
La libreria fin
\end_layout

\begin_layout Standard
La libreria 
\emph on
fin
\emph default
 è il componente principale del sistema e ha il compito di estrarre le features
 caratterizzanti di un brano, garantendo il più possibile, che audio simili
 abbiano features simili.
 D'ora in avanti ci si riferirà alle features indicandole come 
\emph on
Links
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset External
	template Inkscape
	filename img/fin_architettura.svg
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Architettura-fin"

\end_inset

Schema architettura libreria fin
\end_layout

\end_inset


\end_layout

\end_inset

Il punto di ingresso della libreria è un 
\emph on
Reader
\emph default
, ovvero un contenitore dei campioni che compongono un audio; in uscita
 si hanno i 
\emph on
Links
\emph default
 che caratterizzano quell'audio.
 Analizzando più dettagliatamente lo schema in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Architettura-fin"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\end_layout

\begin_layout Enumerate

\series bold
Reader
\series default
 è una classe astratta del namespace 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

readers
\end_layout

\end_inset

, la rappresentazione di un audio nel dominio del tempo.
 La classe definisce un metodo virtuale puro 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

getData()
\end_layout

\end_inset

 che restituisce i campioni dell'audio.
\end_layout

\begin_layout Enumerate

\series bold
Spectrogram
\series default
 è una classe del namespace 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

math
\end_layout

\end_inset

, rappresenta lo spettrogramma di un audio.
 Riceve i campioni dal 
\emph on
Reader
\emph default
 e procede come segue:
\end_layout

\begin_deeper
\begin_layout Enumerate
Finestra il segnale ottenendone un segmento
\end_layout

\begin_layout Enumerate
Calcola la DFT per ogni segmento
\end_layout

\begin_layout Enumerate
Calcola il modulo dell'output della DFT per ogni segmento
\end_layout

\begin_layout Enumerate
Salva il risultato del punto precedente in una struttura chiamata 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

fftWindow
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Le varie 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

fftWindow
\end_layout

\end_inset

 compongono lo spettrogramma, in altre parole una rappresentazione in frequenza
 dell'audio
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
findPeaks
\series default
 è una funziona nel namespace 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

core
\end_layout

\end_inset

 che estrae i picchi più alti
\begin_inset Foot
status open

\begin_layout Plain Layout
Nonchè i più significativi per il sistema in analisi
\end_layout

\end_inset

 dallo spettrogramma.
 Ogni picco è rappresentato da un oggetto 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

Peak
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
i 
\series bold
Links 
\series default
sono il risultato dell'operazione di 
\emph on
fingerprinting
\emph default
, ovvero le features che caratterizzano l'audio.
 Vengono creati a partire dai vari 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

Peak
\end_layout

\end_inset

 estratti da 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

findPeaks
\end_layout

\end_inset

 e fanno parte del namespace 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

core
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Tutte le classi e le funzioni della libreria 
\emph on
fin
\emph default
 sono contenute nel namespace 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

fin
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
La classe Reader e le sue sottoclassi
\end_layout

\begin_layout Standard
La classe 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 generica rappresenta un contenitore di campioni audio.
 Definisce due metodi puri virtuali:
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

getData()
\end_layout

\end_inset

 che ritorna un 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

std::vector<float>
\end_layout

\end_inset

 contenente i campioni
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

dropSamples()
\end_layout

\end_inset

 che svuota il 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

vector
\end_layout

\end_inset

 dei campioni
\end_layout

\begin_layout Standard
\begin_inset Float marginfigure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset External
	template Inkscape
	filename img/readers.svg
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "mar:Ereditarieta-readers"

\end_inset

Schema ereditarietà tra readers
\end_layout

\end_inset


\end_layout

\end_inset

La classe 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 viene estesa da due classi 
\emph on
reader
\emph default
 concrete (vedi figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "mar:Ereditarieta-readers"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

WavReader
\end_layout

\end_inset

, in grado di leggere i file Wave.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

DummyReader
\end_layout

\end_inset

, un mero wrapper attorno al contenitore 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

std::vector
\end_layout

\end_inset

, con un metodo 
\begin_inset listings
lstparams "language={C++},basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

addSamples
\end_layout

\end_inset

 per inserire nuovi samples nel vettore.
\end_layout

\begin_layout Section
Lo spettrogramma
\end_layout

\begin_layout Standard
Lo 
\emph on
spettrogramma
\emph default
 è una rappresentazione tridimensionale del contenuto in frequenza di un
 segnale nel tempo.
\end_layout

\begin_layout Subsection
La finestratura
\end_layout

\begin_layout Standard
\begin_inset Float marginfigure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{axis}[
\end_layout

\begin_layout Plain Layout

		width=
\backslash
textwidth,
\end_layout

\begin_layout Plain Layout

		height=
\backslash
textwidth,
\end_layout

\begin_layout Plain Layout

		domain=0:.08,
\end_layout

\begin_layout Plain Layout

		samples=100,
\end_layout

\begin_layout Plain Layout

		xmin = 0, xmax = .08,
\end_layout

\begin_layout Plain Layout

		ymin =  -2, ymax = 2,
\end_layout

\begin_layout Plain Layout

		grid = major,
\end_layout

\begin_layout Plain Layout

		xlabel = tempo $(s)$,
\end_layout

\begin_layout Plain Layout

		ylabel = ampiezza,
\end_layout

\begin_layout Plain Layout

		axis x line=bottom,
\end_layout

\begin_layout Plain Layout

		axis y line=left
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\backslash
addplot[color=red,mark=x] coordinates { (0,1) (0.02,1) };
\end_layout

\begin_layout Plain Layout

		
\backslash
addplot[color=red,mark=x] coordinates { (0.02,0) (0.1,0) };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\backslash
addplot[
\end_layout

\begin_layout Plain Layout

			color=green,
\end_layout

\begin_layout Plain Layout

			line width=1pt
\end_layout

\begin_layout Plain Layout

		]{
\end_layout

\begin_layout Plain Layout

			sin(deg(pi*120*x))/2 - sin(deg(pi*60*x))/3 - sin(deg(pi*20*x))/6
\end_layout

\begin_layout Plain Layout

		};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
end{axis}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "mar:Finestratura-con-finestra"

\end_inset

Finestratura con finestra rettangolare
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il primo passo per ottenere uno spettrogramma è finestrare il segnale: il
 caso più semplice consiste nel utilizzare una finestra rettangolare come
 indicato in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "mar:Finestratura-con-finestra"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\end_body
\end_document
